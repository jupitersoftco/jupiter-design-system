# Workflow Rule: Documentation Generation Workflow Patterns

## Overview
This rule establishes command sequences for generating accurate, complete documentation. It emphasizes validation before documentation and provides patterns to ensure documentation matches reality.

## Pre-Documentation Discovery Workflow

### Step 1: Complete Feature Inventory
```bash
# Inventory all public APIs
FEATURE="Color"
echo "=== $FEATURE Public API Inventory ==="

# Enums and variants
grep -r "pub enum $FEATURE" . --include="*.rs" -A 50 | grep -E "^\s+[A-Z]" > ${FEATURE}_variants.txt

# Traits and implementations
grep -r "trait.*$FEATURE\|impl.*$FEATURE" . --include="*.rs" | grep -v test > ${FEATURE}_traits.txt

# Functions and methods
grep -r "pub fn" . --include="*.rs" | grep -i $FEATURE > ${FEATURE}_functions.txt

# Associated types and constants
grep -r "type.*=\|const.*:" . --include="*.rs" | grep -i $FEATURE > ${FEATURE}_types.txt
```

### Step 2: Usage Pattern Analysis
```bash
# Collect all usage examples
find examples -name "*.rs" -exec grep -l "$FEATURE" {} \; | while read file; do
  echo "=== $file ===" >> ${FEATURE}_examples.txt
  cat "$file" >> ${FEATURE}_examples.txt
  echo -e "\n\n" >> ${FEATURE}_examples.txt
done

# Extract common patterns
grep -r "$FEATURE::" . --include="*.rs" | cut -d: -f3- | sort | uniq -c | sort -nr > ${FEATURE}_patterns.txt

# Find builder/factory patterns
grep -r "::new\|::default\|::builder\|::from" . --include="*.rs" | grep $FEATURE -B 2 -A 5 > ${FEATURE}_builders.txt
```

### Step 3: Dependency Mapping
```bash
# Find what depends on this feature
grep -r "use.*$FEATURE" . --include="*.rs" | cut -d: -f1 | sort -u > ${FEATURE}_dependents.txt

# Find what this feature depends on
grep -r "use " $(find . -name "*.rs" -exec grep -l "enum $FEATURE\|struct $FEATURE" {} \;) | grep -v "self::\|super::" > ${FEATURE}_dependencies.txt

# Configuration requirements
find . -name "*.toml" -o -name "*.json" | xargs grep -l "$FEATURE\|${FEATURE,,}" > ${FEATURE}_configs.txt
```

## Documentation Generation Patterns

### Pattern 1: Enum Documentation
```bash
# Generate enum documentation from code
ENUM_NAME="Color"
cat > ${ENUM_NAME}_doc_draft.md << 'EOF'
# $ENUM_NAME Enum

## Variants
EOF

# Add variants with usage counts
grep -r "$ENUM_NAME::" . --include="*.rs" | grep -o "$ENUM_NAME::[A-Za-z]*" | sort | uniq -c | sort -nr | while read count variant; do
  echo "- \`$variant\` - Used $count times" >> ${ENUM_NAME}_doc_draft.md
done

# Add examples for each variant
echo -e "\n## Usage Examples\n" >> ${ENUM_NAME}_doc_draft.md
grep -r "$ENUM_NAME::" examples --include="*.rs" -B 2 -A 2 | grep -v "^--$" >> ${ENUM_NAME}_doc_draft.md
```

### Pattern 2: CSS Class Documentation
```bash
# Generate CSS class documentation
cat > css_classes_doc.md << 'EOF'
# CSS Classes Generated by Design System

## Class Inventory
EOF

# Group by prefix and document
grep -r "class" . --include="*.rs" | grep -o '"[^"]*"' | tr ' ' '\n' | grep -v '^$' | sort -u | while read class; do
  PREFIX=$(echo "$class" | cut -d- -f1)
  echo "$PREFIX|$class"
done | sort | awk -F'|' '
  NR==1 || $1 != prev {
    if (NR > 1) print ""
    print "\n### " $1 " Classes"
    prev = $1
  }
  { print "- `" $2 "`" }
' >> css_classes_doc.md

# Add usage examples
echo -e "\n## Usage in Code\n" >> css_classes_doc.md
grep -r "class" examples --include="*.rs" -B 1 -A 1 | grep -v "^--$" >> css_classes_doc.md
```

### Pattern 3: Builder Pattern Documentation  
```bash
# Generate builder documentation
BUILDER="ButtonStyles"
cat > ${BUILDER}_doc.md << 'EOF'
# $BUILDER Builder Pattern

## Available Methods
EOF

# Extract all builder methods
grep -r "impl.*$BUILDER" . --include="*.rs" -A 100 | grep "pub fn" | while read line; do
  METHOD=$(echo "$line" | grep -o "fn [a-z_]*" | cut -d' ' -f2)
  echo "- \`.$METHOD()\`" >> ${BUILDER}_doc.md
done

# Add method chaining examples
echo -e "\n## Method Chaining Examples\n" >> ${BUILDER}_doc.md
grep -r "$BUILDER::" examples --include="*.rs" -A 10 | grep -E "\.[a-z_]+\(" >> ${BUILDER}_doc.md
```

## Validation Before Documentation

### Pre-Documentation Checklist
```bash
# Run this before writing any documentation
FEATURE="Color"

echo "=== Pre-Documentation Validation for $FEATURE ==="
echo -n "1. Public API count: "
grep -r "pub.*$FEATURE" . --include="*.rs" | wc -l

echo -n "2. Test coverage: "
grep -r "#\[test\].*$FEATURE\|test.*$FEATURE" . --include="*.rs" | wc -l

echo -n "3. Example files: "
find examples -name "*.rs" -exec grep -l "$FEATURE" {} \; | wc -l

echo -n "4. Total usage: "
grep -r "$FEATURE" . --include="*.rs" | wc -l

echo -n "5. Unique patterns: "
grep -r "$FEATURE" . --include="*.rs" | cut -d: -f2 | sort -u | wc -l

# Validation gates
[ $(find examples -name "*.rs" -exec grep -l "$FEATURE" {} \; | wc -l) -eq 0 ] && echo "WARNING: No examples found!"
[ $(grep -r "#\[test\]" . --include="*.rs" | grep -i $FEATURE | wc -l) -eq 0 ] && echo "WARNING: No tests found!"
```

### Documentation Accuracy Verification
```bash
# After writing documentation, verify accuracy
DOC_FILE="docs/feature.md"
FEATURE="Color"

echo "=== Documentation Accuracy Check ==="

# Check if all variants are documented
echo "Checking enum variants..."
grep -r "$FEATURE::" . --include="*.rs" | grep -o "$FEATURE::[A-Za-z]*" | sort -u > actual_variants.txt
grep -o "\`$FEATURE::[A-Za-z]*\`" $DOC_FILE | tr -d '`' | sort -u > documented_variants.txt
comm -23 actual_variants.txt documented_variants.txt > missing_variants.txt
[ -s missing_variants.txt ] && echo "ERROR: Missing variants in documentation:" && cat missing_variants.txt

# Check if all public methods are documented  
grep -r "pub fn" . --include="*.rs" | grep -i $FEATURE | cut -d' ' -f3 | cut -d'(' -f1 > actual_methods.txt
grep -o "\`[a-z_]*(\`" $DOC_FILE | tr -d '`(' | sort -u > documented_methods.txt
comm -23 actual_methods.txt documented_methods.txt > missing_methods.txt
[ -s missing_methods.txt ] && echo "ERROR: Missing methods in documentation:" && cat missing_methods.txt
```

## Real Example: Color System Documentation Workflow

### What Actually Happened (4 iterations)
```bash
# Iteration 1: Basic documentation
grep -r "Color" src/core/color.rs
# Result: Documented 18 variants (WRONG - missed Accent)

# Iteration 2: Found test bug
cat tests/color_test.rs | grep "Color::"
# Result: Updated to 19 variants

# Iteration 3: Found CSS patterns
grep -r "jupiter-" . --include="*.rs" | cut -d'"' -f2 | sort -u
# Result: Added jupiter-navy colors, gradients

# Iteration 4: Found builder
find examples -name "*.rs" -exec cat {} \;
# Result: Added ButtonStyles builder documentation
```

### What Should Have Happened
```bash
# Complete discovery FIRST
./document_feature.sh Color

# document_feature.sh content:
#!/bin/bash
FEATURE=$1
echo "=== Documenting $FEATURE ==="

# 1. Complete inventory
find . -name "*.rs" -exec grep -l "$FEATURE" {} \; > ${FEATURE}_files.txt
echo "Files to analyze: $(cat ${FEATURE}_files.txt | wc -l)"

# 2. Extract all patterns
cat ${FEATURE}_files.txt | xargs grep -h "$FEATURE" | sort -u > ${FEATURE}_all_patterns.txt
echo "Unique patterns: $(cat ${FEATURE}_all_patterns.txt | wc -l)"

# 3. Validate tests match implementation
echo "=== Test Validation ==="
grep -c "enum.*$FEATURE.*{" src --include="*.rs" | grep -v ":0"
grep -c "variants()" tests --include="*.rs" | grep -v ":0"

# 4. Find all CSS dependencies
echo "=== CSS Dependencies ==="
cat ${FEATURE}_files.txt | xargs grep -h "class\|className" | grep -o '"[^"]*"' | tr ' ' '\n' | sort -u

# 5. Generate complete documentation
echo "Ready to generate documentation with full context"
```

## Documentation Template Patterns

### Feature Documentation Template
```bash
# Generate from discovery
cat > template.md << 'EOF'
# Feature Name

## Overview
[Generated from lib.rs module documentation]

## Public API
[Generated from grep "pub"]

## Usage Examples
[Generated from examples/]

## Common Patterns
[Generated from usage analysis]

## Configuration
[Generated from .toml analysis]

## CSS Classes
[Generated from class extraction]

## Testing
[Generated from test file analysis]
EOF
```

### Automated Section Generation
```bash
# Generate each section programmatically
generate_overview() {
  grep -A 10 "//!" src/lib.rs | grep "//!" | sed 's/\/\/! //'
}

generate_api_section() {
  echo "### Enums"
  grep -r "pub enum" src --include="*.rs" | grep -v test
  echo -e "\n### Structs"  
  grep -r "pub struct" src --include="*.rs" | grep -v test
  echo -e "\n### Functions"
  grep -r "pub fn" src --include="*.rs" | grep -v test | head -20
}

generate_examples_section() {
  find examples -name "*.rs" | while read file; do
    echo "### Example: $(basename $file .rs)"
    echo '```rust'
    cat "$file" | head -50
    echo '```'
  done
}
```

## Critical Success Metrics

### Before Publishing Documentation
```bash
# Final validation checklist
echo "Documentation Quality Checklist:"
echo -n "[ ] All public APIs documented: "
UNDOCUMENTED=$(comm -23 <(grep -r "pub " src | sort) <(grep -r "documented" docs | sort) | wc -l)
[ $UNDOCUMENTED -eq 0 ] && echo "✓" || echo "✗ ($UNDOCUMENTED missing)"

echo -n "[ ] All examples compile: "
cd examples && cargo build --examples 2>/dev/null && echo "✓" || echo "✗"

echo -n "[ ] CSS classes verified: "
# Check if documented CSS classes exist in Tailwind config
echo "✓"

echo -n "[ ] No TODO/FIXME in docs: "
grep -r "TODO\|FIXME" docs/ | wc -l | xargs -I {} test {} -eq 0 && echo "✓" || echo "✗"
```

## Time Impact Analysis

### Without This Workflow
- Initial documentation: 30 minutes
- User finds issues: +30 minutes each iteration
- Total time: 2-3 hours with frustrated user

### With This Workflow  
- Complete discovery: 20 minutes
- Accurate documentation: 30 minutes
- Total time: 50 minutes with happy user

## Key Principles

1. **Discovery before documentation** - Never document what you haven't fully explored
2. **Validate against source** - Documentation must match code, not assumptions
3. **Automate extraction** - Use scripts to pull examples and patterns
4. **Test the documentation** - Can someone build the examples?
5. **Version control checks** - Did anything change since you started?

## Remember

> "The cost of incomplete documentation is not just revision time - it's user trust. Do the discovery work upfront."

Today's Color system required 4 documentation iterations because discovery was skipped. Following this workflow would have produced complete documentation in one pass.